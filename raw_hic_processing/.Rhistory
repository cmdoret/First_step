print(c(gTAD$start,gTAD$end))
print(paste0("r=",r,"; N=",N,"; D[c]=", D[c]))
print(c(r,r+D[c]))
print(D[c])
diam[c] <-  sum(M[gTAD$start:gTAD$end,r:(r+D[c])])*(L[c]/R) # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
for(i in 5:7){testmat[[1]][6,i]<-1}
for(i in 6:7){testmat[[1]][7,i]<-1}
testmat
testmat <- list(matrix(rep(0,100),nrow=10),"1")
for(i in 1:10){testmat[[1]][i,i] <- 1}
for(i in 5:7){testmat[[1]][4:7,i]<-1}
for(i in 6:7){testmat[[1]][5:7,i]<-1}
testmat
for(i in 4:7){testmat[[1]][4:7,i]<-1}
for(i in 6:7){testmat[[1]][5:7,i]<-1}
testmat
testmat <- list(matrix(rep(0,100),nrow=10),"1")
for(i in 1:10){testmat[[1]][i,i] <- 1}
for(i in 4:7){testmat[[1]][4:7,i]<-1}
tesmta
tesmtat
tesmat
testmat
testmat[[1]][6,7]<-1
testmat <- list(matrix(rep(0,100),nrow=10),"1")
for(i in 1:10){testmat[[1]][i,i] <- 1}
for(i in 4:7){testmat[[1]][4:7,i]<-1}
tstmat
testmat
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
testmat
3*58+5*20+5*10+5
1*58+5*20+5*10+3*5
meantestmat)
mean(testmat)
mean(testmat[[1]])
sum(testmat[[1]])
a <- c(1,2,3)
b <- c(4,5,6)
mean(a,b)
rowMean(a,b)
rowMeans(a,b)
rowMeans(submat[,1]
)
submat[,1]
submat <- testmat[4:7,4:5]
testmat
submat <- testmat[[1]][4:7,4:5]
submat
submat[,length(submat[1,])]
submat[,1] <- c(1,2,3,4)
submat[,length(submat[1,])]
submat[,length(submat[1,])]<-c(4,5,6,7)
submat
rowMeans(submat[,1],submat[,length(submat[1,])])
rowMeans(submat[,c(1,length(submat[1,]))])
1+4
firstlast <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))]<-firstlast
submat
index_2_pos <- function(ind, resolution=5000) { return(resolution * (ind - 1)) }# Finding actual position in genome from bin number.
pos_2_index <- function(pos, resolution=5000) { return(1 + (pos / resolution))  }  # Finding index in vector from entry in matrix
# m=contact matrix; R=resolution; L=vector containing length of genes;S=vector containing start of genes
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
D<-floor(pos_2_index(L,R))-1  # Transforming length of genes into number of bins.
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; D[c]=", D[c]))
submat <- M[gTAD$start:gTAD$end,(r:r+D[c])]
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))]<-first.last_avg
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
D<-floor(pos_2_index(L,R))-1  # Transforming length of genes into number of bins.
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; D[c]=", D[c]))
submat <- M[gTAD$start:gTAD$end,(r:r+D[c])]
print(submat)
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))]<-first.last_avg
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
# m=contact matrix; R=resolution; L=vector containing length of genes;S=vector containing start of genes
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
D<-floor(pos_2_index(L,R))-1  # Transforming length of genes into number of bins.
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; D[c]=", D[c]))
submat <- matrix(M[gTAD$start:gTAD$end,(r:r+D[c])],ncol = D)
print(submat)
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))]<-first.last_avg
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
a+b
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
D<-floor(pos_2_index(L,R))-1  # Transforming length of genes into number of bins.
E <- ceiling(pos_2_index(S+L))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; D[c]=", D[c]))
submat <- M[gTAD$start:gTAD$end,(r:E[c])]
print(submat)
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))] <- first.last_avg
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
d
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
# m=contact matrix; R=resolution; L=vector containing length of genes;S=vector containing start of genes
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- ceiling(pos_2_index(S+L))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; D[c]=", D[c]))
submat <- M[gTAD$start:gTAD$end,r:E[c]]
print(submat)
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))] <- first.last_avg
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- ceiling(pos_2_index(S+L))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; E[c]=", E[c]))
submat <- M[gTAD$start:gTAD$end,r:E[c]]
print(submat)
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))] <- first.last_avg
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
subma <- 0
submat <- 0
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- ceiling(pos_2_index(S+L))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; E[c]=", E[c]))
submat <- M[gTAD$start:gTAD$end,r:E[c]]
print(submat)
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))] <- first.last_avg
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- ceiling(pos_2_index(S+L,R))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; E[c]=", E[c]))
submat <- M[gTAD$start:gTAD$end,r:E[c]]
print(submat)
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))] <- first.last_avg
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
linc <- data.frame(chr=c(1,1),start=c(14,16),end=c(16,22),gene=c("a","b"),strand=c("+","+"))
TAD <- data.frame(chr=1,start=15,end=30,ID="TAD")
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- ceiling(pos_2_index(S+L,R))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; E[c]=", E[c]))
submat <- M[gTAD$start:gTAD$end,r:E[c]]
print(submat)
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))] <- first.last_avg
print(submat)
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- ceiling(pos_2_index(S+L,R))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; E[c]=", E[c]))
submat <- M[gTAD$start:gTAD$end,r:E[c]]
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))] <- first.last_avg
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
testmat
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- ceiling(pos_2_index(S+L,R))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; E[c]=", E[c]))
submat <- M[gTAD$start:gTAD$end,r:E[c]]
print(submat)
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))] <- first.last_avg
diam[c] <-  mean(submat[,1:(length(submat[1,])-1]))  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- ceiling(pos_2_index(S+L,R))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; E[c]=", E[c]))
submat <- M[gTAD$start:gTAD$end,r:E[c]]
print(submat)
first.last_avg <- rowMeans(submat[,c(1,length(submat[1,]))])
submat[,c(1,length(submat[1,]))] <- first.last_avg
diam[c] <-  mean(submat[,1:(length(submat[1,])-1)])  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
diam_slide<-function(m,R=5000,S , L, tad){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- floor(pos_2_index(S+L,R))  # storing indexes of end positions
int_tad <- Intervals(matrix(c(tad$start,tad$end),ncol=2))
int_linc <- Intervals(matrix(c(S,S+L),ncol=2))
rownames(int_tad) <- tad$ID
for(r in i){  # Iterating over genes
over <-interval_overlap(int_tad,int_linc[c])
gTAD <- tad[tad$ID==names(unlist(over[over!=0])),]
if(length(gTAD[,1])>0){
gTAD$start <- pos_2_index(gTAD$start,R)
gTAD$end <- pos_2_index(gTAD$end,R)
print(paste0("r=",r,"; N=",N,"; E[c]=", E[c]))
submat <- M[gTAD$start:gTAD$end,r:E[c]]
diam[c] <-  mean(submat)  # desired width of square (based on gene length)
} else{
diam[c] <- 0
}
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
diam_slide<-function(m,R=5000,S , L){  # L = vector containing each gene length; R = resolution, m = intrachromosomal matrix
N <- length(m[[1]][1,])  # Storing number of cols
M <- m[[1]]  # Transforming matrix into vector
diam <- rep(0,times=length(L)) # preallocating space for diamond-summed data.
c <- 1
i <- rep(0,length(L)) #preallocating space for vector indexes of start sites
for(d in 1:length(L)){i[d]<-floor(pos_2_index(S[d],R))}  #transforming start position into rounded vector indexes
E <- floor(pos_2_index(S+L,R))  # storing indexes of end positions
for(r in i){  # Iterating over genes
print(paste0("r=",r,"; N=",N,"; E[c]=", E[c]))
diam[c] <-  mean(M[1:N,r:E[c]]) # desired width of square (based on gene length)
# Storing normalized diamond sums in vector
c <- c+1
}
return(cbind(linc,diam))
}
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),tad=TAD,R = 5)
diam_slide(testmat, S=linc$start, L=as.vector(linc$end-linc$start),R = 5)
